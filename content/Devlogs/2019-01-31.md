title: Jan 2019
_This is the first in my monthly Devlog series. Unfortunately January being January I don't have much excitement to kick things off with. This feature is replacing my "Projects" Feature which has now been unpublished. To begin with I am publishing the entries in reverse 
date order, to be consistent with page listings in the menus. I might change this if it is too unreadable. If you want chronological order please read it backwards_ ðŸ˜œ

# 20/01/19:
I just am checking in; I haven't had much opportunity to get any project work done In over two weeks, which sucks. The most "dev-y" thing I have been done since December is spending a few hours suring-up my network infrastructure. I switched my primary Storage/VM/Media 
server over to arch's LTS kernel in a hope that it would improve system stability. Knock on wood so far it's working better. 

I also tried to recover an offsite backup server, that "disappeared" all the way back in November. I am assured by it's local guardian that it boots up, but I am no longer able to access it. After swapping some config files on the cold root OS and still nothing. I have had 
to retire that remote until I can get back to it in person.

I have also been following some tutorials on binary reversing, with the hope that I can do some reversing CTF's later in the year as part of the Infosec society in my university. I am using Radare2 as my disassembler, as I am a poor student and can't even afford Binary 
Ninja.

# 07/01/19:
I spent an evening musing about my latest big project, which I am in the mood to attempt off the back of my sucess with devemember. That said I have Exams through most of this month, so I won't have time to actually start work on this until next momth. 

## So I have finally gone mad enough to attempt this!
Rule 1. of computing is "computers cannot think, they just follow a predefined set of instructions, therefore they cannot have a creative spark" So why how could a computer possibly write a song? 

Short Answer is **"MATH!!!"** Long answer is Music is deeply mathematical and can be modelled with surprising effectiveness. Meanwhile programming is it's self a a deeply creative task that _requires_ that creative spark. So where these two points overlap we can shunt the 
creative workload from a composer to a algorithm designer. 

The Goal isn't to build the most amazing dynamic music in the world either. This project was actually inspired in part by DJ's opping lounges at many hacker conferences (see GPN and C3) and in part by lofi continuous mixes that were very popular on YouTube in 2016/17. 

What these have in common is the audience wants dynamic background music to whatever they are doing, that is not to complex or distracting but still energetic enough to be enjoyed on it's own. We're aiming a bit higher than elevator music, but we're not trying to make new 
hit's here!

There is a slight sadistic twist to the motivation of this project. Some of the aforementioned DJ's are scraping the very bottom of the barrel, producing the most uninspired electronic / house mixes and sometimes (especially @ GPN) don't know what their audience wants. _"A 
rising tide lifts all boats."_ If I can prove I can algorithmically generate not only a better mix, but dynamically compose the songs as well then maybe I can encourage the other 'players' to up their game.
